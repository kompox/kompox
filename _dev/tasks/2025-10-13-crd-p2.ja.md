---
id: 2025-10-13-crd-p2
title: CLI への CRD 取り込み統合
status: done
updated: 2025-10-13
language: ja
owner: yaegsahi
---
# Task: CLI への CRD 取り込み統合

## 目的

- [K4x-ADR-007] の Phase 2 を実装する。
- v1 CLI (kompoxops) に CRD スタイル設定の取り込み経路を統合し、仕様どおりの優先度・検証・既定アプリ名推定を実現する。
- 既存の `--db-url` (既定 `file:kompoxops.yml`) 互換を維持しつつ、CRD 入力が有効な場合は CRD モードへ切り替える。
- CRD モードでは各リソース (Workspace/Provider/Cluster/App) の ID を FQN で永続化し、FK も FQN を直接参照させる。

## スコープ / 非スコープ

- In:
  - グローバルオプション `--crd-path` (複数指定) / `--crd-app` (既定 `./kompoxapp.yml`) の実装
  - 環境変数 `KOMPOX_CRD_PATH` (カンマ区切り) 、`KOMPOX_CRD_APP` の対応 (フラグ優先)
  - 取り込み/検証成功時に CRD モードを有効化し、当該セッションの `--db-url`/`KOMPOX_DB_URL` を無視
  - CLI に `--app-id`/`--cluster-id` を追加し、各リソースの ID (FQN) を直接受け付けて UseCase の `Get` で解決する
  - 後方互換のため `--app-name`/`--cluster-name` も残すが、該当リソースが複数見つかる場合は即座にエラーとする(曖昧解決しない)
  - 自動設定は `--app-id` および `--cluster-id` に対してのみ行う（単名の自動解決はしない）
  - `--crd-app` 範囲に App が「ちょうど 1 件」の場合、その App の FQN を `--app-id` の既定値として採用
  - 上記 App が参照する Cluster が一意に決まる場合、その Cluster の FQN を `--cluster-id` の既定値として採用
  - 全ドキュメント収集後の整合検証 (オール・オア・ナッシング) とエラーの文脈 (ファイルパス + 1-based ドキュメント番号)
  - UseCase/Repo への反映と既存フロー (kube.Converter など) への影響最小化
- Out:
  - v2 Operator 実装 (将来タスク)
  - RDB Sink の導入 (Phase 3)
  - Cluster storage/Operator の Watch 実装 (Phase 4)

## 仕様サマリ

- フラグ/環境変数、優先度、既定推定、検証は次を参照:
  - ADR: [K4x-ADR-007] (CLI ingestion (v1))
  - CLI 仕様: [Kompox-CLI.ja.md] ("CLI 設定と読み込みモード")
  - CRD 仕様: [Kompox-CRD.ja.md] ("CLI 取り込み経路と優先度 (kompoxops)")
- CRD v1alpha API は次を参照:
  - [config/crd/ops/v1alpha1/README.md]

### FQN と ID の取り扱い

- FQN を Kompox 内部の正規 ID とする。各 Kind の FQN は次の通り:
  - WorkspaceID: `ws`
  - ProviderID: `ws/prv`
  - ClusterID: `ws/prv/cls`
  - AppID: `ws/prv/cls/app`
- Sink.ToModels():
  - 変換時に各モデルの `ID` に FQN を設定し、親 FK にも親の FQN をそのまま設定する
  - これにより name ベースの曖昧解決を不要化し、ストア間で一貫した参照が可能
- リポジトリ契約:
  - Create は事前に設定された `ID` を尊重（空のときのみ採番）
  - Get は `ID`(=FQN) をキーに単一取得

### CLI のリソース指定

- 追加フラグ:
  - `--app-id, -A`: AppID (FQN: `ws/prv/cls/app`)
  - `--cluster-id, -C`: ClusterID (FQN: `ws/prv/cls`)
- 互換フラグ(非推奨表示):
  - `--app-name`: 単名/部分指定を受け付けるが、複数一致した場合は即座にエラー
  - `--cluster-name`: 同上(複数一致時はエラー)。
- 既定/自動設定:
  - `--crd-app` の範囲に App がちょうど 1 件ある場合は、その App の FQN を `--app-id` 既定として採用
  - 上記 App が参照する Cluster が一意に決まれば、その FQN を `--cluster-id` 既定として採用
  - 既定は ID フラグ（`--app-id`/`--cluster-id`）に対してのみ行う。name フラグの既定は行わない

## 計画 (チェックリスト)

- [x] CLI フラグの追加
  - [x] `cmd/kompoxops` の共通オプションに `--crd-path` (StringArray) と `--crd-app` (String) を追加
  - [x] 環境変数 `KOMPOX_CRD_PATH` (カンマ区切り) / `KOMPOX_CRD_APP` を取り込み、フラグで上書き
  - [x] `--crd-path` は存在確認 (存在しなければエラー) / `--crd-app` は存在しなければ無視
- [x] ローダー/バリデータ統合
  - [x] `config/crd/ops/v1alpha1` Loader/Sink を用意し、入力パス群から .yml/.yaml を再帰読込 (マルチドキュメント対応)
  - [x] 収集後に整合検証、失敗時は DB へ反映せず詳細エラー (パス + ドキュメント番号)
  - [x] 成功時のみストアに FQN 主キーで一括反映（Sink.ToModels で ID/FK を FQN に設定）
- [x] CRD モード有効化と優先度
  - [x] CRD 入力が 1 件以上かつ検証成功なら CRD モードを有効化
  - [x] CRD モード有効時は `--db-url`/`KOMPOX_DB_URL` を無視 (セッション内)
  - [x] CRD 入力が無ければ既定どおり `--db-url` (既定 `file:kompoxops.yml`) を使用
- [x] 既定 ID の推定
  - [x] `--crd-app` 由来の入力に App がちょうど 1 件なら `--app-id` 未指定時に App の FQN を採用
  - [x] 上記 App が参照する Cluster が一意に決まれば `--cluster-id` 未指定時に Cluster の FQN を採用
- [x] ヘルプ/ドキュメント整合
  - [x] `kompoxops --help` に `--crd-path`/`--crd-app` を反映 (説明は仕様に準拠)
  - [x] design/v1/Kompox-CLI.ja.md の記載と差異が無いか確認
- [x] CLI フラグの更新
  - [x] `--app-id`/`--cluster-id` を追加し、UseCase は `Get(ID)` で取得する
  - [x] `--app-name`/`--cluster-name` は残すが、複数一致時はエラー（曖昧解決しない）
- [x] テスト（ユニット/統合）
  - [x] `--crd-path` の単体/複数/存在しないパスの挙動
  - [x] CRD 読み込み成功で `--db-url` を無視すること
  - [ ] `--crd-app` による既定 AppID/ClusterID の推定 (1 件/0 件/2 件の各ケース)
  - [x] 整合検証 NG 時に DB 未更新でエラーがドキュメント位置を含むこと
  - [x] 後段 (kube.Converter) への影響が無いこと (既存テストがグリーン)

## テスト

- ユニット:
  - フラグ/環境変数のマージ、パス存在判定、`--crd-app` の存在無視
  - Loader の受理条件（GVK、ファイル拡張子、マルチドキュメント）
  - バリデーション（親存在、重複検出、順序、FQN キー生成）
- 統合/スモーク:
  - CRD モード有効化と `--db-url` 無視の確認
  - `--crd-app` による既定アプリ名の推定
  - 失敗時のエラーメッセージ (ファイル/ドキュメント番号)

## 受け入れ条件

- `kompoxops` が `--crd-path`/`--crd-app` を受け付け、仕様どおりの優先度で動作する
- CRD 読み込み成功時に `--db-url` が無視される (セッション内)
- `--crd-app` に App が 1 件のみ存在する場合、`--app-id` 未指定時に当該 App の FQN が既定採用される
- 上記により `--cluster-id` も一意に決まる場合は、`--cluster-id` 未指定時に当該 Cluster の FQN が既定採用される
- 検証失敗時に DB 未更新、エラーメッセージにファイルパスと 1-based ドキュメント番号が含まれる
- 既存の単一ファイルモード (`file:kompoxops.yml`) の動作に回 regress が無い
- `--app-name`/`--cluster-name` は複数候補が見つかった場合に即座にエラーとなる（候補一覧の提示はしてよいが自動選択はしない）
- UseCase は ID(FQN) を受け取り、対応する `Get(ID)` で単一リソースを取得できる

## メモ

- CLI 実装はフラグ/環境変数の解決を早期に行い、以降の処理は単一の「構成入力ソース (CRD or db-url)」に集約して扱うと複雑度が下がる。
- CRD モードの有効/無効はコンテキストに明示化し、後段 UseCase では差異を意識しないで済む形にする。
- Loader/Validator のエラーメッセージ整形は再利用可能な小ユーティリティに分離するとよい。

## 進捗

- 2025-10-13: タスク作成 (仕様参照の明記、チェックリスト初期化)
- 2025-10-13: 実装完了
  - CLI フラグ `--crd-path` (StringArray), `--crd-app` (String) を追加
  - 環境変数 `KOMPOX_CRD_PATH`, `KOMPOX_CRD_APP` のサポート（フラグ優先）
  - CRD モードの初期化とローダー/バリデータ統合 (`cmd/kompoxops/crd_loader.go`)
  - `buildRepos` を更新して CRD モード時に CRD Sink を使用
  - `getAppName` を更新して CRD モードの既定アプリ名をサポート
  - ユニットテスト追加 (`crd_loader_test.go`, `crd_integration_test.go`)
  - テストサンプル追加 (`_tmp/tests/crd-basic.yml`, `_tmp/tests/crd-single-app.yml`)
  - すべてのテスト通過 (`make test`)
  - E2E 動作確認完了 (CRD モードでの app list, app validate)
- 2025-10-13: リファクタリングとテスト拡充
  - `config/crd/ops/v1alpha1/converter.go` を `sink_tomodels.go` に改名 (Go 命名規則に従う)
  - Sink の変換ロジック (`ToModels` メソッド) を CLI 層から CRD パッケージに移動
  - `sink_tomodels_test.go` を追加 (8+ テストケース: 正常系5件、異常系3件、エラーハンドリング1件)
  - `config/crd/ops/v1alpha1/README.md` を更新:
    - Package Structure に `sink_tomodels.go` を追加
    - セクション6を3.2に統合 (Sink API 関連を一箇所にまとめる)
    - Test Coverage に `sink_tomodels_test.go` を追加
  - すべてのテスト通過 (`make test`)、パッケージ構成の整理完了
- 2025-10-13: コード整理と責務の明確化
  - `repos_builder.go` を3ファイルに分割 (main, CRD, DB)
    - `repos_builder.go`: メインルーティング (`buildRepos` と各 UseCase 用ビルダー)
    - `repos_builder_crd.go`: CRD モード専用ロジック (`buildReposFromCRD`, `getCRDDefaultAppName`)
    - `repos_builder_db.go`: DB モード専用ロジック (`buildReposFromDB`, `getDBDefaultAppName`, キャッシュ管理)
  - 関数名の明確化:
    - `getDefaultAppName` → `getCRDDefaultAppName` (CRD モード専用であることを明示)
    - `getDBDefaultAppName` を新規追加 (DB モードのデフォルトアプリ名取得)
  - `cmd_app.go` の `getAppName` を更新:
    - 優先順位を明確化: `--app-name` フラグ > CRD デフォルト > DB (kompoxops.yml) デフォルト
    - 各ステップに番号付きコメントを追加
  - `crd_loader.go` から `getCRDDefaultAppName` を削除 (CRD ビルダーに移動)
  - すべてのテスト通過 (`make test`)、ビルド成功 (`make build`)
- 2025-10-13: E2E テストインフラと型変換の改善
  - E2E テストテンプレート作成 (`tests/aks-e2e-crd/`)
    - `kompoxops.yml.in`: マルチドキュメント CRD 形式テンプレート
    - `crd.templates/`: workspace.yml, provider.yml, cluster.yml, app.yml (個別ファイル形式)
    - Makefile に `crd` ターゲット追加 (テンプレート展開用)
  - **重要な型変換バグ修正**: `config/crd/ops/v1alpha1/loader.go`
    - 問題: YAML に数値やブール値を記述すると "json: cannot unmarshal number into Go struct field" エラー
    - 原因: `mapToStruct` が `map[string]any` → JSON → struct パスを使用し、JSON の厳密な型制約に違反
    - 解決: `mapToStruct` を JSON ベースから **YAML ベース**に変更
    - `json.Marshal` → `yaml.Marshal` (sigs.k8s.io/yaml) に切り替え
    - YAML は数値やブール値を `map[string]string` に自動変換するため、`Settings` フィールドへの格納が成功
  - テスト統合と拡充:
    - `TestLoader_TypeConversion` を追加 (14 テストケース)
    - 文字列、整数 (64)、浮動小数点 (3.14)、ブール値 (true/false)、ゼロ値 (0) のすべてを検証
    - Provider.Settings, Cluster.Settings, App.Resources, App.Settings の各フィールドをカバー
    - `loader_settings_test.go` を削除し、`loader_test.go` に統合
  - すべてのテスト通過 (`go test ./config/crd/ops/v1alpha1`, `make test`)
- 2025-10-13: デフォルトクラスタ名の推定機能を追加
  - `getClusterName()` を `getAppName()` と同様の3段階優先度に変更:
    1. `--cluster-name` フラグ（明示的指定）
    2. CRD モードのデフォルト（単一アプリが参照するクラスタ）
    3. `kompoxops.yml` の `cluster.name`
  - 実装の詳細:
    - `crd_loader.go`: `crdModeContext.defaultClusterName` フィールドを追加
    - `initializeCRDMode()`: App の `metadata.annotations["ops.kompox.dev/path"]` からクラスタ名を抽出
    - `repos_builder_crd.go`: `getCRDDefaultClusterName()` を追加
    - `repos_builder_db.go`: `getDBDefaultClusterName()` を追加
    - `cmd_cluster.go`: `getClusterName()` を更新（優先度ロジック実装）
  - CRD モードで `--cluster-name` を省略可能に（単一アプリの場合）
  - すべてのテスト通過 (`make test`)、ビルド成功 (`make build`)
- 2025-10-13: 仕様更新 (FQN=ID と CLI ID フラグ)
  - Sink.ToModels で Workspace/Provider/Cluster/App の `ID` を FQN に、親 FK も FQN で保存する方針を明記
  - CLI に `--app-id`/`--cluster-id` を追加し、UseCase は `Get(ID)` で解決
  - `--app-name`/`--cluster-name` は後方互換として維持するが、複数一致時はエラーとする
  - 既定の自動設定は ID フラグに対してのみ実施（`--crd-app` で App が 1 件なら AppID、参照 Cluster が一意なら ClusterID）
- 2025-10-13: FQN ベース ID の実装完了
  - **Sink.ToModels の更新**: 各リソースの ID に FQN を設定、親 FK も親の FQN を直接設定
    - `Workspace.ID = fqn.String()` (例: `"my-ws"`)
    - `Provider.ID = fqn.String()`, `Provider.WorkspaceID = parentPath` (例: `"my-ws/my-prv"`, FK: `"my-ws"`)
    - `Cluster.ID = fqn.String()`, `Cluster.ProviderID = parentPath` (例: `"my-ws/my-prv/my-cls"`, FK: `"my-ws/my-prv"`)
    - `App.ID = fqn.String()`, `App.ClusterID = parentPath` (例: `"my-ws/my-prv/my-cls/my-app"`, FK: `"my-ws/my-prv/my-cls"`)
  - **親リソースのクエリ削除**: parentPath が既に FQN なので、List() を呼んで検索する必要がなくなった
  - **テストの更新**:
    - モックリポジトリ: `Create()` メソッドで事前設定された ID を尊重するように修正（空の場合のみ自動生成）
    - 期待値を FQN 形式に更新（例: `"ws-test-ws"` → `"test-ws"`, `"prv-my-prv"` → `"my-ws/my-prv"`)
    - 全テストパス (`config/crd/ops/v1alpha1`: 42 テスト、全体: 回帰なし)
- 2025-10-13: CLI フラグとリソース解決の実装完了
  - **新規フラグの追加**:
    - `--app-id` (FQN: `ws/prv/cls/app`): App ID を直接指定
    - `--cluster-id` (FQN: `ws/prv/cls`): Cluster ID を直接指定
    - 既存の `--app-name` / `--cluster-name` は後方互換のため維持
  - **CRD モードコンテキストの拡張**:
    - `crdModeContext` に `defaultAppID`, `defaultClusterID` フィールドを追加
    - `initializeCRDMode()`: 単一 App がある場合、その FQN を `defaultAppID` に、参照する Cluster の FQN を `defaultClusterID` に設定
    - `getCRDDefaultAppID()`, `getCRDDefaultClusterID()`: CRD モードのデフォルト ID (FQN) を返す関数
  - **優先度ロジックの実装**:
    - `getAppName()`: `--app-id` > `--app-name` > CRD default (FQN) > DB default (name)
    - `getClusterName()`: `--cluster-id` > `--cluster-name` > CRD default (FQN) > DB default (name)
  - **名前解決関数の追加**:
    - `resolveAppID(ctx, appUC, idOrName)`: ID/名前を受け取り、FQN を返す。名前の場合は List() で検索し、複数一致時はエラー
    - `resolveClusterID(ctx, clusterUC, idOrName)`: 同上（Cluster 用）
  - **コマンドの更新**:
    - `cmd_app.go`: validate, deploy, destroy, status, exec, logs - すべて `resolveAppID()` を使用するように更新
    - `cmd_cluster.go`: provision, deprovision, install, uninstall, status, kubeconfig, logs - すべて `resolveClusterID()` を使用するように更新
    - `cmd_box.go`: deploy, destroy, status, exec, ssh, scp, rsync - すべて `resolveBoxAppID()` (共通パターン) を使用するように更新
    - `cmd_disk.go`: list, create, assign, delete - すべて `resolveDiskAppID()` を使用するように更新
    - `cmd_snapshot.go`: list, create, delete - すべて `resolveSnapshotAppID()` (disk と共通) を使用するように更新
    - `cmd_dns.go`: `--app-id` フラグを追加（app コマンドと共通の `flagAppID` を使用）
    - エラーメッセージ: 複数一致時は候補一覧を表示（例: `"multiple apps found with name \"test\": [ws1/prv1/cls1/test, ws2/prv2/cls2/test] (use --app-id to specify)"`）
  - **テスト**: すべてのユニットテストが通過、ビルド成功
  - **ヘルプ確認**:
    - `./kompoxops app --help`: `--app-id` と `--app-name` が表示される
    - `./kompoxops cluster --help`: `--cluster-id` と `--cluster-name` が表示される
    - `./kompoxops box --help`: `--app-id` と `--app-name` が表示される
    - `./kompoxops disk --help`: `--app-id` と `--app-name` が表示される
    - `./kompoxops snapshot --help`: `--app-id` と `--app-name` が表示される
    - `./kompoxops dns --help`: `--app-id` と `--app-name` が表示される
- 2025-10-13: フラグ変数とリソース解決関数の統一
  - **グローバルフラグ変数への統一**:
    - 各コマンドグループ専用のフラグ変数を削除（`flagBoxAppID`, `flagBoxAppName`, `flagVolumeAppID`, `flagVolumeAppName` など）
    - すべてのコマンドでグローバル変数 `flagAppID`, `flagAppName`, `flagClusterID`, `flagClusterName` を共有
  - **リソース解決関数の統一**:
    - 各コマンドグループ専用の resolve 関数を削除（`resolveBoxAppID`, `resolveDiskAppID`, `resolveSnapshotAppID`, `resolveDNSAppID`, `resolveSecretAppID`, `resolveSecretPullAppID` など）
    - 共有関数 `resolveAppID(ctx, domain.AppRepository, args)` を使用するように統一
    - シグネチャ変更: UseCase 全体ではなく `domain.AppRepository` を受け取るように変更（各 UseCase は `.Repos.App` でアクセス可能）
  - **更新したファイルと関数**:
    - `cmd_app.go`: `resolveAppID()` の実装（参照実装）、6 コマンド更新
    - `cmd_box.go`: 専用フラグ/関数削除、7 コマンド更新（deploy/destroy/status/exec/ssh/scp/rsync）
    - `cmd_disk.go`: 専用フラグ/関数削除、4 コマンド更新（list/create/assign/delete）
    - `cmd_snapshot.go`: 専用フラグ/関数削除、3 コマンド更新（list/create/delete）
    - `cmd_dns.go`: 専用関数削除、2 コマンド更新（deploy/destroy）
    - `cmd_secret_env.go`: 専用関数削除、2 コマンド更新（set/delete）
    - `cmd_secret_pull.go`: 専用関数削除、2 コマンド更新（set/delete）
  - **不要な import の削除**: 専用 resolve 関数で使用していた `strings` パッケージを各ファイルから削除
  - **コード削減**: 各コマンドグループごとに 4 項目（フラグ変数 2 個 + 関数 2 個）を削除 → 1 つの共有関数に統一
  - **テスト**: すべてのユニットテストが通過、ビルド成功（`make build`）
  - **影響範囲**: 合計 8 ファイル、33 コマンドを更新
- 2025-10-13: クラスタリソース解決の統一と最適化
  - **resolveClusterID() のリファクタリング**:
    - シグネチャ変更: `resolveClusterID(ctx, *cluster.UseCase, idOrName)` → `resolveClusterID(ctx, domain.ClusterRepository, args)`
    - `domain.ClusterRepository` を直接受け取るように変更（各 UseCase は `.Repos.Cluster` でアクセス）
    - 優先度ロジックを関数内に統合（`--cluster-id` > `--cluster-name` > CRD default > DB default）
  - **getClusterName() の削除**:
    - 2段階呼び出し（`getClusterName()` → `resolveClusterID()`）を1段階（`resolveClusterID()`）に簡素化
  - **更新したコマンド（7個）**:
    - `cmd_cluster.go`: provision/deprovision/install/uninstall/status/kubeconfig/logs
    - すべてのコマンドで `resolveClusterID(ctx, clusterUC.Repos.Cluster, args)` を使用
  - **domain import の追加**: `"github.com/kompox/kompox/domain"` を追加
  - **テスト**: すべてのユニットテストが通過、ビルド成功（`make build`）
- 2025-10-13: Name 系ヘルパー関数の完全削除と直接参照への移行
  - **削除した関数（6個）**:
    - `repos_builder_crd.go`: `getCRDDefaultAppName()`, `getCRDDefaultAppID()`, `getCRDDefaultClusterName()`, `getCRDDefaultClusterID()`
    - `repos_builder_db.go`: `getDBDefaultAppName()`, `getDBDefaultClusterName()`
  - **削除したフィールド（2個）**:
    - `crd_loader.go` の `crdModeContext` 構造体: `defaultAppName`, `defaultClusterName`
  - **直接参照への変更**:
    - `cmd_app.go` の `resolveAppID()`: `crdMode.defaultAppID` と `configRoot.App.Name` を直接参照
    - `cmd_cluster.go` の `resolveClusterID()`: `crdMode.defaultClusterID` と `configRoot.Cluster.Name` を直接参照
  - **crd_loader.go の簡素化**:
    - `initializeCRDMode()` で `defaultAppName` と `defaultClusterName` への代入を削除
    - FQN (ID) のみを設定するロジックに統一
  - **テストの更新**:
    - `crd_integration_test.go`: `defaultAppName` のテストを `defaultAppID` に変更
    - `strings` パッケージを追加
  - **結果**: ID (FQN) ベースの実装に完全統一、関数呼び出しオーバーヘッドを削減
  - **テスト**: すべてのテストがパス（`make test` 成功）
- 2025-10-13: 不要なタイムアウトコンテキストの削除
  - **cmd_box.go の最適化**:
    - `resolveAppID()` 呼び出しのためだけの短期タイムアウトコンテキスト（2分）を削除
    - 対象コマンド（4個）: exec/ssh/scp/rsync
    - 変更: `rctx, cancel := context.WithTimeout(ctx, 2*time.Minute)` を削除し、直接 `ctx` を使用
  - **理由**:
    - `resolveAppID()` は高速操作（リポジトリ検索と名前マッチング）のため専用タイムアウト不要
    - これらのコマンドは長時間実行される可能性があるため、親コンテキストをそのまま使用するのが適切
  - **結果**: コードが簡潔になり、不要なコンテキスト作成のオーバーヘッドを削減
  - **テスト**: ビルド成功（`make build`）
- 2025-10-13: App spec フィールド変換バグの修正
  - **問題の発見**:
    - CRD モードで `kompoxapp.yml` を読み込んだ際、`spec` フィールド（Compose、Ingress、Deployment など）が空のままだった
    - `admin app list` の出力で Compose="", Ingress.CertResolver="", Deployment.Zone="" など、すべてのspecフィールドが欠落
    - metadata.name は正しく読み込まれており、Loader は正常動作していることを確認
  - **根本原因**:
    - `config/crd/ops/v1alpha1/sink_tomodels.go` の `ToModels()` メソッドで、App のドメインモデル変換時に ID、Name、ClusterID の3フィールドしかコピーしていなかった
    - 同じファイル内の Cluster 変換では Spec.Ingress と Spec.Settings を正しくコピーしているのに、App 変換では全 spec フィールドが欠落
  - **修正内容** (`sink_tomodels.go` lines 115-165):
    - `Compose`: 文字列フィールドをそのまま domainApp にコピー
    - `Ingress`: CertResolver + Rules 配列を変換（nil チェックあり、値型として代入）
      - Rules: Name, Port, Hosts を含む配列を変換
    - `Volumes`: Name, Size, Options を持つ配列に変換（nil チェックあり）
    - `Deployment`: Pool + Zone フィールドを変換（nil チェックあり、値型として代入）
    - `Resources`: マップをそのままコピー
    - `Settings`: マップをそのままコピー
  - **テストの追加** (`sink_tomodels_test.go`):
    - `app_with_full_spec`: すべてのspecフィールドが正しく変換されることを検証
      - Compose: マルチライン YAML 文字列
      - Ingress: certResolver + 2つのrules（それぞれ複数のhosts）
      - Volumes: 2つのvolume（size + options付き）
      - Deployment: pool + zone
      - Resources: cpu + memory
      - Settings: replicas + nodeSelector
    - `app_with_minimal_spec`: Composeのみのケースで他フィールドが空/nilであることを確認
      - Ingress.CertResolver が空文字列、Rules が空配列であることを検証
      - Volumes が nil であることを検証
      - Deployment.Pool と Zone が空文字列であることを検証
      - Resources と Settings が nil であることを検証
    - `app_with_ingress_but_no_rules`: IngressのcertResolverのみでrulesがない場合を検証
  - **検証結果**:
    - テストYAMLファイル作成（`_tmp/test-app-spec.yml`）: Workspace/Provider/Cluster/App の完全な階層構造
    - `./kompoxops --crd-path=test-app-spec.yml admin app list` で全フィールドが正しく読み込まれることを確認:
      - ✅ Compose: Docker Compose 内容が含まれている
      - ✅ Ingress.CertResolver: "letsencrypt"
      - ✅ Ingress.Rules: web (port 80, 2 hosts) + api (port 8080, 1 host)
      - ✅ Volumes: data (10GB, Premium_LRS) + cache (5GB, Standard_LRS)
      - ✅ Deployment: Pool="user", Zone="1"
      - ✅ Resources: cpu="1000m", memory="1Gi"
      - ✅ Settings: replicas="3", nodeSelector="disktype=ssd"
    - 元の `aks-e2e-crd` テストケースでも検証:
      - `./kompoxops --crd-path=crd admin app list` で Compose="file:compose.yml", Ingress.CertResolver="staging", Ingress.Rules, Deployment.Zone="1" が正しく表示
    - ユニットテスト: 10個すべてパス（`go test ./config/crd/ops/v1alpha1/`）
  - **影響範囲**: CRD モードでの App 作成/取得が機能するようになり、CRD 統合が完全に動作可能に
- 2025-10-13: CLI フラグ短縮形のバインディング修正
  - **問題の発見**:
    - `-A` が `--app-name` にバインドされていた（仕様では `--app-id` にバインドすべき）
    - `-C` が `--cluster-name` にバインドされていた（仕様では `--cluster-id` にバインドすべき）
    - 短縮形が name フラグに割り当てられていたため、ID ベースの操作が不便だった
  - **修正内容**:
    - 6つのコマンドファイルで短縮形のバインディングを変更:
      - `cmd_app.go`: `-A` を `--app-id` に、`-C` を `--cluster-id` に変更
      - `cmd_cluster.go`: `-C` を `--cluster-id` に変更
      - `cmd_box.go`: `-A` を `--app-id` に変更
      - `cmd_disk.go`: `-A` を `--app-id` に変更
      - `cmd_snapshot.go`: `-A` を `--app-id` に変更
      - `cmd_dns.go`: `-A` を `--app-id` に変更
    - name フラグは短縮形なしで明示的に指定する形に変更（後方互換性のため保持）
    - 各フラグに "for backward compatibility" コメントを追加
  - **検証結果**:
    - ビルド成功（`make cmd`）
    - すべてのテストがパス（`go test ./cmd/kompoxops/`）
    - ヘルプ出力確認:
      - `./kompoxops app --help`: `-A, --app-id` と `--app-name` が表示
      - `./kompoxops cluster --help`: `-C, --cluster-id` と `--cluster-name` が表示
      - 他のコマンドでも同様に正しく表示
  - **影響**: ID ベースの操作がより直感的になり、CRD モードでの使い勝手が向上
- 2025-10-13: CRD モードでの compose file 展開機能の実装
  - **問題の発見**:
    - CRD モードで App の `spec.compose` に `file:compose.yml` と指定しても、ファイル内容が展開されず文字列 "file:compose.yml" のまま保持されていた
    - 単一ファイルモード（`kompoxops.yml`）では `config/kompoxopscfg/converter.go` の `processCompose()` 関数がファイル展開を行うが、CRD モードには同等の処理がなかった
  - **実装内容**:
    - **アノテーション定義追加** (`types.go`):
      - `AnnotationDocPath = "ops.kompox.dev/doc-path"`: ソースドキュメントファイルパスを保存
      - `AnnotationDocIndex = "ops.kompox.dev/doc-index"`: マルチドキュメントYAML内の位置（1-based）を保存
    - **Loader の拡張** (`loader.go`):
      - `setDocumentAnnotations()` ヘルパー関数を追加（繰り返しを削減）
      - 各リソース（Workspace/Provider/Cluster/App/Box）のパース時にドキュメントメタデータをアノテーションに保存
      - `metav1` パッケージをインポート
    - **Sink の compose 処理追加** (`sink_tomodels.go`):
      - `processCompose(compose, baseDir)` 関数を追加:
        - `file:` プレフィックスを検出
        - 相対パスをソースファイルのディレクトリから解決
        - ファイル内容を読み込んで返す
      - `ToModels()` メソッドを更新:
        - App 変換時に `AnnotationDocPath` からソースファイルパスを取得
        - `filepath.Dir()` でベースディレクトリを取得
        - `processCompose()` を呼び出してファイル展開を実行
      - `os`, `path/filepath`, `strings` パッケージをインポート
  - **検証結果**:
    - ビルド成功（`make cmd`）
    - テストがパス（`go test ./config/crd/ops/v1alpha1/`）
    - `/workspaces/kompox/kompoxops --crd-path=./crd admin app list` 実行結果:
      - ✅ Compose フィールドが `"file:compose.yml"` から実際の YAML コンテンツに展開
      - ✅ マルチライン Docker Compose 定義が正しく読み込まれている
      - ✅ services/app/image、env_file、environment、ports などすべてのフィールドが含まれる
  - **参考実装**: `config/kompoxopscfg/converter.go` の `processCompose()` と `readComposeFile()` 関数
  - **影響範囲**: CRD モードで compose file 参照が正しく動作し、単一ファイルモードと同等の機能を実現

## 参考

- [K4x-ADR-007]
- [Kompox-CLI.ja.md]
- [Kompox-CRD.ja.md]
- [config/crd/ops/v1alpha1/README.md]

[K4x-ADR-007]: ../../design/adr/K4x-ADR-007.md
[Kompox-CLI.ja.md]: ../../design/v1/Kompox-CLI.ja.md
[Kompox-CRD.ja.md]: ../../design/v1/Kompox-CRD.ja.md
[config/crd/ops/v1alpha1/README.md]: ../../config/crd/ops/v1alpha1/README.md